# My Technology Roadmap
## Internet
### HTTP
### HTTPS

## Browser

### DNS
### Domain Name

## Frontend

### HTML

### CSS

### webpack
### 前端工程化

## OS

## Node
### Module
#### Node模块介绍
#### 模块的实现
#### 模块的加载和缓存

## Addons
### C++ Addons扩展使用场景介绍
在Node中需要使用C++扩展的场景不是很多，主要有以下两类：
1. 已经有C的实现，但是由于语言限制、时间等其他因素，不方便实现JS版本，此时可以使用C扩展，直接使用已经实现的能力
2. 有性能要求，大部分场景下，C++的性能还是比JS要高的
EventLoop
Promise
垃圾回收
Node的堆内存大致可以分为两个部分：
• 新生代  
• 老生代  

新生代内存区域的特点：
1. 内存空间小
2. 垃圾回收频繁
老生代内存区域的特点：
1. 内存空间大
2. 存活对象占比大
关于内存大小的数据如下：  
V8堆内存的最大值：64位系统上为1464MB，32位系统上732MB。  
新生代的内存：64位系统上为32MB，32位系统上为16MB。  
可以看出新生代的内存占总内存的比例约为2.2%。  
V8的垃圾回收策略是基于分代的垃圾回收机制。由于新生代、老生代两者的特性不同，故而垃圾回收的算法是不一样的。  

**新生代**  
新生代内存区由于内存区域小、垃圾回收频繁，使用的是Scavenge算法。  
Scavenge的基本思想：  
```
将内存空间一分为二，每一个空间被称为semispace。
两个semispace总有一个处于使用状态，另一个处于闲置状态。
处于使用状态的semispace叫from；处于闲置状态的semispace叫to。
在为对象分配内存时总是使用from空间进行分配。
在进行垃圾回收的时候，v8检查from空间中的对象，依然存活的对象（还在被引用的对象）被复制到to空间，剩下的对象就会被释放。
最后将from空间和to空间的角色对调。
```
当一个对象在经过几次垃圾回收后依然存活，此时这个对象就会“晋升”(从新生代移动到老生代)，晋升的条件：
1. 在垃圾回收过程中，对象已经经过了一次新生代的清理依然存活。
2. 在垃圾回收过程中，新生代的to空间使用率超过25%。   
满足上面条件中的一个，对象就会晋升，从新生代移动到老生代。

**老生代**

老生代由于存活对象占比大，内存空间大，所以不适合使用Scavenge算法进行垃圾回收，所以老生代使用的是Mark-Sweep(标记清除)和Mark-Compact(标记整理)算法结合的方式进行内存回收。主要是用的Mark-Sweep算法，当老生代的空间不足以分配从新生代晋升来的对象时，使用Mark-Compact算法。  

### V8
### libuv

## CommonJS && ECMAScript

## JavaScript

## TypeScript

## MYSQL
### 索引
### 事务
### 集群

## Redis
### 缓存
### 哨兵
### 集群

## Mongodb

## Go
参考文档
Developer Roadmaps: https://roadmap.sh